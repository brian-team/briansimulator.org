<html><body><ol>
	<li><strong>Why the name 'Brian'?</strong> Some things are best left as mysteries.</li>
	<li><strong>Who is Brian for?</strong> Brian has been designed for quick development and testing of neural network models (check the <a href="http://www.briansimulator.org/docs/examples.html" rel="nofollow">examples on the web site</a>). It is reasonably fast in many circumstances (check the question on speed below), but another simulator may be more appropriate if you have specific needs. For example, for very large-scale distributed simulations of integrate-and-fire models, you could use NEST. For complex biophysical models of neurons with dendritic morphologies, Neuron or Genesis is probably a better choice. If you want to program quickly models with a single or few compartments, then Brian is a good choice.</li>
	<li><strong>Will Brian be supported in the long term?</strong> Yes. First, we are already using Brian for several projects in the lab (involving several other people) and we are adding new features regularly. Second, we have an open source strategy: the source code is freely available and we are welcoming every kind of contribution (including participating in a support mailing list); we are trying as much as possible to organize the code so that it is easy for anyone to add new features. Third, we rely as much as possible on mature third-party packages which have a much larger base of users, such as Scipy and Pylab, so that the core of the simulator is not that big (in fact it only took us a few months to develop the first release).</li>
	<li><strong>What platforms are supported?</strong> All platforms running Python, so at least Windows, Linux and Mac.</li>
	<li><strong>Can I plot and/or analyse the results of a simulation from my Brian script?</strong> Absolutely! Since Brian is a Python package, you can use all Python scientific and graphic packages. We use Scipy for scientific computing and Pylab for graphics.</li>
	<li><strong>How fast is Brian?</strong> It depends. The idea is that, in order to keep the interpretation cost relatively low, many identical operations should be performed at each time step. Thus, large networks of neurons run fast (about 25% slower than C for integrate-and-fire models), but single neuron simulations are (proportionnally) slow. However, for single neuron simulations, one often wants to simulate the model for many parameter or stimulus values; in this case, the same speed-up applies and the simulation is fast. The one case that will remain slow is when one wants to simulate a single neuron for a very long time.</li>
	<li><strong>Does Brian have support for distributed computing?</strong> A little bit. It is possible to run independent simulations on several processors or computers (with a server-client architecture) using the Parallel Python package.</li>
	<li><strong>What integration methods does Brian use?</strong> For linear differential equations, Brian uses exact integration. For nonlinear equations, it uses forward Euler, Runge-Kutta (explicit) or exponential Euler (implicit). Spike timing interpolation is also planned but not implemented yet.</li>
	<li><strong>How do I define the connectivity of a network?</strong> You can define connectivity either by (a) using our built in methods such as connect_full and connect_random, (b) passing a connectivity function f(i,j), (c) construct the connectivity programmatically, by writing things like C[i,j]=1 where C is a Connection, (d) pass a matrix of connection strengths directly.</li>
	<li><strong>What standard models does Brian have?</strong> The first release of Brian includes various integrate and fire models (perfect, leaky, exponential, Izhikevich, Brette-Gerstner), currents (Hodgkin-Huxley K and Na), synapses (exponential, alpha and biexponential currents and conductances), and random processes (Ornstein-Uhlenbeck). At the moment, these can be found in the brian.library packages. It is also very easy to program other models (check the examples).</li>
	<li><strong>Does Brian do compartmental modelling?</strong> It is possible but there is very limited support for the moment (see compartments.py and examples/cable.py), that is, it is possible to do it by defining every compartment separately and connecting them. No specific integration method is included yet, so you should not expect it to be very efficient if there are many compartments. It should be fine however for models with a few compartments. We are planning on adding some enhanced support soon.</li>
	<li><strong>Are event-driven algorithms implemented?</strong> No, for the moment only clock-driven algorithms are implemented. We do however plan on adding some limited support for (exact) event-driven algorithms. The problem is that the efficiency is based on using vector-based operations, which is possible only if there are many synchronous operations. This could still be the case for event-driven algorithms with homogeneous delays (or at least not too many different delays).</li>
	<li><strong>Is synaptic plasticity implemented?</strong> Short-term plasticity and spike-timing dependent plasticity (STDP) are both implemented.</li>
	<li><strong>Do I need a C compiler?</strong> No, but it can be useful. We have implemented a few key functions in C and are working on an automatic (optional) code generation mechanism which would speed-up the update phase (especially for complex models).So Brian will be faster if you have one, but it is not required.</li>
	<li><strong>What will be the next features of Brian?</strong> Probably distributed computing (GPU and multi-core processors). Please tell us if there is a specific feature that you would like to see.</li>
</ol></body></html>